---
title: Objective-C 的内存管理
date: 2018-06-08 18:26:29
tags:
---

#### 前言：

iOS 内存管理相关的内容其实已经一大堆了，为了加强理解，写了这篇读书笔记。有任何不对的地方，还望大家批评指正。

#### 正文：

##### C 语言内存模型
说 Objective-C 的内存管理之前，可以了解一下 C 的内存模型

内存分区有哪些？
栈、全局(静态)区、堆、字符串常量区

* 栈(stack):C语言函数内部变量包括局部变量和形式参数等。在进入函数的时候自动分配，在离开函数时自动清除的变量存储区。

* 全局/静态区(global/static):存放全局变量和静态变量的存储区。全局变量也称为外部变量，它是在函数外部定义的变量。全局变量是所有函数的公用变量，整个程序中任何一个函数都可以任意地调用它。静态变量和全局变量被分配到同一块内存中，静态局部变量只限于在定义处的函数使用，但是离开函数后数值一直保留，直到程序退出。

* 堆(heap):由调用malloc函数分配的内存块，一般每一次malloc函数分配的内存块，最后都要对应调用一次free函数释放这个内存块。如果程序员没有释放掉，那么在程序结束后，操作系统会自动释放。

* 常量储存区:就是存放程序内所有字符串常量的内存区域，这个内存区域上存储的内容不允许修改，直到程序退出为止。

```
int a = 0;  // 全局
char *p;    // 全局

int main(int argc, const char * argv[]) {
    
    int b;  // 栈
    char s[] = "abc";   // 栈
    char *p1;   // 栈
    char *p2 = "123456";    // 123456/0在常量区，p2在栈上
    static int c = 0;   // 全局
    p = (char *)malloc(10);    // 堆
    p1 = (char *)malloc(20);    // 堆
    return 0;
}
```

**区别:**
1. 栈由系统自动分配，不用担心释放问题；堆需要程序员自己申请，那就需要程序员来释放。
2. 栈由系统自动分配，速度就比较快；堆是`new`或者`malloc`出来，一般速度比较慢，而且容易产生内存碎片（话说 OC 中的`allocWithZone:`中这个'zone'，貌似就是减少碎片产生的存在）。
3. 栈是一块连续的内存区域，内存大小比较小；堆是不连续的，比较大。


##### 引用计数
先来说说垃圾回收机制。如上所说，虽然栈中内存会自动释放，但堆中的已分配内存需要我们自己来释放。自己来管理内存的话，释放时机的把握就很重要了。如果释放早了，还有其他地方在使用这块内存中的对象，那就形成了垂悬指针。或者本来这块内存中的对象已经没地方用了，你又没释放，本来就很着急的内存空间，怕是要溢出了。所以，垃圾回收机制就是解决这个问题的。

传统算法：

* 引用计数(Reference Counting)算法
* 标记-清除(Mark-Sweep)算法
* 复制(Copying)算法

标记-清除算法：简单来说，就是轮询所有对象，把被引用的对象标记起来，轮询结束后就清除所有没有被标记的对象。

复制算法：把堆空间分成A、B两份，每次只使用其中之一。假设先使用 A 区域，当系统认为需要回收垃圾时，把所有正在被使用的对象复制到 B 区域。然后清空 A。到下一次需要收集时，再在 B 中正在被使用的对象复制到 A，然后清空 B。

Objective-C 中的内存管理用的就是引用计数：每次有对象被引用，那么对象的计数就+1，当你不在引用这个对象时，就告诉对象，让他计数-1。当计数为0时，就释放该对象。

有这样一个口诀：

* 自己生成的对象，自己持有
* 非自己生成的对象，自己也能持有。
* 不再需要自己持有的对象时释放。
* 非自己持有的对象无法释放。

未完待续......

